name: Progressive Deployment Pipeline

# ============================================================================
# Progressive Deployment: dev ‚Üí staging ‚Üí prod
# Each stage must pass before the next begins
# Single trigger on telegram branch - auto-promotes through all environments
# ============================================================================
on:
  push:
    branches:
      - telegram  # Single trigger - auto-chains through dev ‚Üí staging ‚Üí prod
    paths:
      - 'src/**'
      - 'frontend/telegram-webapp/**'
      - 'Dockerfile*'
      - 'requirements*.txt'
      - 'terraform/**'
      - '.github/workflows/**'
  pull_request:
    branches:
      - telegram
    paths:
      - 'src/**'
      - 'frontend/telegram-webapp/**'
      - 'Dockerfile*'
      - 'requirements*.txt'

env:
  AWS_REGION: ap-southeast-1
  PYTHON_VERSION: '3.11'
  ECR_REGISTRY: 755283537543.dkr.ecr.ap-southeast-1.amazonaws.com

jobs:
  ###############################################################################
  # Stage 0: Quality Gates (runs on PR and push)
  ###############################################################################
  test:
    name: Quality Gates
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pip-audit

      - name: Syntax check
        run: |
          echo "üîç Checking Python syntax..."
          python -m py_compile src/**/*.py src/api/*.py dr_cli/**/*.py
          echo "‚úÖ Syntax check passed"

      - name: Unit tests
        run: |
          echo "üß™ Running unit tests..."
          pytest tests/shared tests/telegram -v --tb=short \
            -k "not integration and not smoke and not e2e" \
            --ignore=tests/integration/ \
            --ignore=tests/line_bot/ \
            --ignore=tests/telegram/test_e2e_frontend.py
          echo "‚úÖ Unit tests passed"

      - name: Security audit
        run: |
          echo "üîí Running security audit..."
          pip-audit --strict --desc || echo "‚ö†Ô∏è Security warnings found (non-blocking)"
        continue-on-error: true

  ###############################################################################
  # Stage 1: Build (immutable artifact - built once, promoted through envs)
  ###############################################################################
  build:
    name: Build Image
    needs: [test]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      image_uri: ${{ steps.build.outputs.image_uri }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to ECR
        id: build
        run: |
          # Generate immutable tag (no env prefix - same image for all envs)
          SHA_SHORT=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="sha-${SHA_SHORT}-${TIMESTAMP}"

          # Use dev ECR repo as the source (image is promoted, not rebuilt)
          ECR_REPOSITORY="dr-daily-report-lambda-dev"
          IMAGE_URI="${{ env.ECR_REGISTRY }}/${ECR_REPOSITORY}:${IMAGE_TAG}"

          echo "üì¶ Building Docker image..."
          echo "   Tag: ${IMAGE_TAG}"
          echo "   URI: ${IMAGE_URI}"

          docker build \
            -f Dockerfile.lambda.container \
            -t ${IMAGE_URI} \
            -t ${{ env.ECR_REGISTRY }}/${ECR_REPOSITORY}:latest \
            .

          echo "üöÄ Pushing to ECR..."
          docker push ${IMAGE_URI}
          docker push ${{ env.ECR_REGISTRY }}/${ECR_REPOSITORY}:latest

          echo "‚úÖ Image pushed: ${IMAGE_URI}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build.outputs.image_uri }}
          format: 'table'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'

  ###############################################################################
  # Stage 2: Deploy to Dev
  ###############################################################################
  deploy-dev:
    name: Deploy Dev
    needs: [build]
    runs-on: ubuntu-latest
    environment: development

    outputs:
      telegram_version: ${{ steps.deploy-telegram.outputs.version }}
      worker_version: ${{ steps.deploy-worker.outputs.version }}
      prev_telegram_version: ${{ steps.get-current.outputs.telegram_version }}
      prev_worker_version: ${{ steps.get-current.outputs.worker_version }}

    env:
      ENV_NAME: dev
      TELEGRAM_FUNCTION: dr-daily-report-telegram-api-dev
      WORKER_FUNCTION: dr-daily-report-report-worker-dev

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current versions (for rollback)
        id: get-current
        run: |
          TELEGRAM_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          WORKER_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          echo "üìå Current dev versions: Telegram=${TELEGRAM_VERSION}, Worker=${WORKER_VERSION}"
          echo "telegram_version=${TELEGRAM_VERSION}" >> $GITHUB_OUTPUT
          echo "worker_version=${WORKER_VERSION}" >> $GITHUB_OUTPUT

      - name: Deploy Telegram API Lambda
        id: deploy-telegram
        run: |
          echo "üîÑ Deploying to ${{ env.TELEGRAM_FUNCTION }}..."
          aws lambda update-function-code \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }} \
            --publish \
            --query 'Version' \
            --output text > version.txt
          aws lambda wait function-updated --function-name ${{ env.TELEGRAM_FUNCTION }}
          NEW_VERSION=$(cat version.txt)
          aws lambda update-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Dev Telegram API: version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Deploy Report Worker Lambda
        id: deploy-worker
        run: |
          echo "üîÑ Deploying to ${{ env.WORKER_FUNCTION }}..."
          aws lambda update-function-code \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }} \
            --publish \
            --query 'Version' \
            --output text > version.txt
          aws lambda wait function-updated --function-name ${{ env.WORKER_FUNCTION }}
          NEW_VERSION=$(cat version.txt)
          aws lambda update-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Dev Worker: version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

  ###############################################################################
  # Stage 2b: Deploy Dev Frontend
  ###############################################################################
  deploy-dev-frontend:
    name: Deploy Dev Frontend
    needs: [deploy-dev]
    runs-on: ubuntu-latest
    environment: development

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy frontend to S3
        run: |
          mkdir -p build
          cp -r frontend/telegram-webapp/* build/
          sed -i "s|window.TELEGRAM_API_URL = '{{API_URL}}'|window.TELEGRAM_API_URL = '${{ secrets.TELEGRAM_API_URL }}'|g" build/index.html
          aws s3 sync build/ s3://${{ secrets.WEBAPP_BUCKET_NAME }}/ --delete
          echo "‚úÖ Dev frontend deployed"

      - name: Invalidate CloudFront
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          if [ -n "${DIST_ID}" ]; then
            aws cloudfront create-invalidation \
              --distribution-id ${DIST_ID} \
              --paths "/*" > /dev/null
            echo "‚úÖ Dev CloudFront invalidated"
          else
            echo "‚è≠Ô∏è No CloudFront distribution configured"
          fi

  ###############################################################################
  # Gate 1: Smoke Test Dev (must pass before staging)
  ###############################################################################
  smoke-dev:
    name: Smoke Test Dev
    needs: [build, deploy-dev, deploy-dev-frontend]
    runs-on: ubuntu-latest
    environment: development

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run smoke tests
        env:
          API_URL: ${{ secrets.TELEGRAM_API_URL }}
        run: |
          echo "üî• Smoke testing DEV environment..."
          echo "   API URL: ${API_URL}"

          # Test 1: Health
          HEALTH_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/v1/health")
          if [ "$HEALTH_CODE" != "200" ]; then
            echo "‚ùå Health check failed: ${HEALTH_CODE}"
            exit 1
          fi
          echo "‚úÖ Health check passed"

          # Test 2: Search
          SEARCH_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/v1/search?q=NVDA")
          if [ "$SEARCH_CODE" != "200" ]; then
            echo "‚ùå Search endpoint failed: ${SEARCH_CODE}"
            exit 1
          fi
          echo "‚úÖ Search endpoint passed"

          # Test 3: Rankings
          RANKINGS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/v1/rankings?category=top_gainers&limit=5")
          if [ "$RANKINGS_CODE" != "200" ]; then
            echo "‚ùå Rankings endpoint failed: ${RANKINGS_CODE}"
            exit 1
          fi
          echo "‚úÖ Rankings endpoint passed"

          echo "üéâ DEV smoke tests passed!"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üö® Dev smoke tests failed! Rolling back..."
          aws lambda update-alias \
            --function-name dr-daily-report-telegram-api-dev \
            --name live \
            --function-version ${{ needs.deploy-dev.outputs.prev_telegram_version }}
          aws lambda update-alias \
            --function-name dr-daily-report-report-worker-dev \
            --name live \
            --function-version ${{ needs.deploy-dev.outputs.prev_worker_version }}
          echo "‚úÖ Dev rollback complete"
          exit 1

  ###############################################################################
  # Stage 3: Deploy to Staging (only runs after dev passes)
  ###############################################################################
  deploy-staging:
    name: Deploy Staging
    needs: [build, smoke-dev]  # KEY: waits for dev smoke tests to pass
    runs-on: ubuntu-latest
    environment: staging

    outputs:
      telegram_version: ${{ steps.deploy-telegram.outputs.version }}
      worker_version: ${{ steps.deploy-worker.outputs.version }}
      prev_telegram_version: ${{ steps.get-current.outputs.telegram_version }}
      prev_worker_version: ${{ steps.get-current.outputs.worker_version }}

    env:
      ENV_NAME: staging
      TELEGRAM_FUNCTION: dr-daily-report-telegram-api-staging
      WORKER_FUNCTION: dr-daily-report-report-worker-staging

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current versions (for rollback)
        id: get-current
        run: |
          TELEGRAM_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          WORKER_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          echo "üìå Current staging versions: Telegram=${TELEGRAM_VERSION}, Worker=${WORKER_VERSION}"
          echo "telegram_version=${TELEGRAM_VERSION}" >> $GITHUB_OUTPUT
          echo "worker_version=${WORKER_VERSION}" >> $GITHUB_OUTPUT

      - name: Deploy Telegram API Lambda
        id: deploy-telegram
        run: |
          echo "üîÑ Deploying SAME image to staging..."
          aws lambda update-function-code \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }} \
            --publish \
            --query 'Version' \
            --output text > version.txt
          aws lambda wait function-updated --function-name ${{ env.TELEGRAM_FUNCTION }}
          NEW_VERSION=$(cat version.txt)
          aws lambda update-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Staging Telegram API: version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Deploy Report Worker Lambda
        id: deploy-worker
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }} \
            --publish \
            --query 'Version' \
            --output text > version.txt
          aws lambda wait function-updated --function-name ${{ env.WORKER_FUNCTION }}
          NEW_VERSION=$(cat version.txt)
          aws lambda update-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Staging Worker: version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

  ###############################################################################
  # Stage 3b: Deploy Staging Frontend
  ###############################################################################
  deploy-staging-frontend:
    name: Deploy Staging Frontend
    needs: [deploy-staging]
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy frontend to S3
        run: |
          mkdir -p build
          cp -r frontend/telegram-webapp/* build/
          sed -i "s|window.TELEGRAM_API_URL = '{{API_URL}}'|window.TELEGRAM_API_URL = '${{ secrets.TELEGRAM_API_URL }}'|g" build/index.html
          aws s3 sync build/ s3://${{ secrets.WEBAPP_BUCKET_NAME }}/ --delete
          echo "‚úÖ Staging frontend deployed"

      - name: Invalidate CloudFront
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          if [ -n "${DIST_ID}" ]; then
            aws cloudfront create-invalidation \
              --distribution-id ${DIST_ID} \
              --paths "/*" > /dev/null
            echo "‚úÖ Staging CloudFront invalidated"
          else
            echo "‚è≠Ô∏è No CloudFront distribution configured"
          fi

  ###############################################################################
  # Gate 2: Smoke Test Staging (must pass before prod)
  ###############################################################################
  smoke-staging:
    name: Smoke Test Staging
    needs: [build, deploy-staging, deploy-staging-frontend]
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run smoke tests
        env:
          API_URL: ${{ secrets.TELEGRAM_API_URL }}
        run: |
          echo "üî• Smoke testing STAGING environment..."
          echo "   API URL: ${API_URL}"

          HEALTH_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/v1/health")
          if [ "$HEALTH_CODE" != "200" ]; then
            echo "‚ùå Health check failed: ${HEALTH_CODE}"
            exit 1
          fi
          echo "‚úÖ Health check passed"

          SEARCH_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/v1/search?q=NVDA")
          if [ "$SEARCH_CODE" != "200" ]; then
            echo "‚ùå Search endpoint failed: ${SEARCH_CODE}"
            exit 1
          fi
          echo "‚úÖ Search endpoint passed"

          RANKINGS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/v1/rankings?category=top_gainers&limit=5")
          if [ "$RANKINGS_CODE" != "200" ]; then
            echo "‚ùå Rankings endpoint failed: ${RANKINGS_CODE}"
            exit 1
          fi
          echo "‚úÖ Rankings endpoint passed"

          echo "üéâ STAGING smoke tests passed!"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üö® Staging smoke tests failed! Rolling back..."
          aws lambda update-alias \
            --function-name dr-daily-report-telegram-api-staging \
            --name live \
            --function-version ${{ needs.deploy-staging.outputs.prev_telegram_version }}
          aws lambda update-alias \
            --function-name dr-daily-report-report-worker-staging \
            --name live \
            --function-version ${{ needs.deploy-staging.outputs.prev_worker_version }}
          echo "‚úÖ Staging rollback complete"
          exit 1

  ###############################################################################
  # Stage 4: Deploy to Prod (only runs after staging passes)
  ###############################################################################
  deploy-prod:
    name: Deploy Prod
    needs: [build, smoke-staging]  # KEY: waits for staging smoke tests to pass
    runs-on: ubuntu-latest
    environment: production

    outputs:
      telegram_version: ${{ steps.deploy-telegram.outputs.version }}
      worker_version: ${{ steps.deploy-worker.outputs.version }}
      prev_telegram_version: ${{ steps.get-current.outputs.telegram_version }}
      prev_worker_version: ${{ steps.get-current.outputs.worker_version }}

    env:
      ENV_NAME: prod
      TELEGRAM_FUNCTION: dr-daily-report-telegram-api-prod
      WORKER_FUNCTION: dr-daily-report-report-worker-prod

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current versions (for rollback)
        id: get-current
        run: |
          TELEGRAM_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          WORKER_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          echo "üìå Current prod versions: Telegram=${TELEGRAM_VERSION}, Worker=${WORKER_VERSION}"
          echo "telegram_version=${TELEGRAM_VERSION}" >> $GITHUB_OUTPUT
          echo "worker_version=${WORKER_VERSION}" >> $GITHUB_OUTPUT

      - name: Deploy Telegram API Lambda
        id: deploy-telegram
        run: |
          echo "üîÑ Deploying SAME image to prod..."
          aws lambda update-function-code \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }} \
            --publish \
            --query 'Version' \
            --output text > version.txt
          aws lambda wait function-updated --function-name ${{ env.TELEGRAM_FUNCTION }}
          NEW_VERSION=$(cat version.txt)
          aws lambda update-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Prod Telegram API: version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Deploy Report Worker Lambda
        id: deploy-worker
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }} \
            --publish \
            --query 'Version' \
            --output text > version.txt
          aws lambda wait function-updated --function-name ${{ env.WORKER_FUNCTION }}
          NEW_VERSION=$(cat version.txt)
          aws lambda update-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Prod Worker: version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

  ###############################################################################
  # Stage 4b: Deploy Prod Frontend
  ###############################################################################
  deploy-prod-frontend:
    name: Deploy Prod Frontend
    needs: [deploy-prod]
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy frontend to S3
        run: |
          mkdir -p build
          cp -r frontend/telegram-webapp/* build/
          sed -i "s|window.TELEGRAM_API_URL = '{{API_URL}}'|window.TELEGRAM_API_URL = '${{ secrets.TELEGRAM_API_URL }}'|g" build/index.html
          aws s3 sync build/ s3://${{ secrets.WEBAPP_BUCKET_NAME }}/ --delete
          echo "‚úÖ Prod frontend deployed"

      - name: Invalidate CloudFront
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          if [ -n "${DIST_ID}" ]; then
            aws cloudfront create-invalidation \
              --distribution-id ${DIST_ID} \
              --paths "/*" > /dev/null
            echo "‚úÖ Prod CloudFront invalidated"
          else
            echo "‚è≠Ô∏è No CloudFront distribution configured"
          fi

  ###############################################################################
  # Gate 3: Smoke Test Prod (final verification)
  ###############################################################################
  smoke-prod:
    name: Smoke Test Prod
    needs: [build, deploy-prod, deploy-prod-frontend]
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run smoke tests
        env:
          API_URL: ${{ secrets.TELEGRAM_API_URL }}
        run: |
          echo "üî• Smoke testing PROD environment..."
          echo "   API URL: ${API_URL}"

          HEALTH_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/v1/health")
          if [ "$HEALTH_CODE" != "200" ]; then
            echo "‚ùå Health check failed: ${HEALTH_CODE}"
            exit 1
          fi
          echo "‚úÖ Health check passed"

          SEARCH_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/v1/search?q=NVDA")
          if [ "$SEARCH_CODE" != "200" ]; then
            echo "‚ùå Search endpoint failed: ${SEARCH_CODE}"
            exit 1
          fi
          echo "‚úÖ Search endpoint passed"

          RANKINGS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/api/v1/rankings?category=top_gainers&limit=5")
          if [ "$RANKINGS_CODE" != "200" ]; then
            echo "‚ùå Rankings endpoint failed: ${RANKINGS_CODE}"
            exit 1
          fi
          echo "‚úÖ Rankings endpoint passed"

          echo "üéâ PROD smoke tests passed!"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üö® Prod smoke tests failed! Rolling back..."
          aws lambda update-alias \
            --function-name dr-daily-report-telegram-api-prod \
            --name live \
            --function-version ${{ needs.deploy-prod.outputs.prev_telegram_version }}
          aws lambda update-alias \
            --function-name dr-daily-report-report-worker-prod \
            --name live \
            --function-version ${{ needs.deploy-prod.outputs.prev_worker_version }}
          echo "‚úÖ Prod rollback complete"
          exit 1

  ###############################################################################
  # Final: Deployment Summary
  ###############################################################################
  notify:
    name: Deployment Complete
    needs: [build, deploy-dev, deploy-staging, deploy-prod, smoke-prod]
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: Deployment Summary
        run: |
          echo "üéâ Progressive Deployment Complete!"
          echo ""
          echo "üì¶ Image: ${{ needs.build.outputs.image_tag }}"
          echo ""
          echo "üè∑Ô∏è  Deployed to all environments:"
          echo "   ‚úÖ Dev:     Telegram v${{ needs.deploy-dev.outputs.telegram_version }}, Worker v${{ needs.deploy-dev.outputs.worker_version }}"
          echo "   ‚úÖ Staging: Telegram v${{ needs.deploy-staging.outputs.telegram_version }}, Worker v${{ needs.deploy-staging.outputs.worker_version }}"
          echo "   ‚úÖ Prod:    Telegram v${{ needs.deploy-prod.outputs.telegram_version }}, Worker v${{ needs.deploy-prod.outputs.worker_version }}"
          echo ""
          echo "All smoke tests passed!"
# 2025-11-30T16:30:46+07:00
