name: CI/CD Pipeline

# ============================================================================
# Branch + Path Triggers
# Environment branches: telegram (dev) ‚Üí telegram-staging ‚Üí telegram-prod
# NOTE: main branch is NOT included - see .claude/CLAUDE.md MAIN BRANCH PROTECTION
# ============================================================================
on:
  push:
    branches:
      - telegram           # ‚Üí Dev environment
      - telegram-staging   # ‚Üí Staging environment
      - telegram-prod      # ‚Üí Production environment
    paths:
      - 'src/**'
      - 'frontend/telegram-webapp/**'
      - 'Dockerfile*'
      - 'requirements*.txt'
      - 'terraform/**'
      - '.github/workflows/**'
  pull_request:
    branches:
      - telegram
      - telegram-staging
      - telegram-prod
    paths:
      - 'src/**'
      - 'frontend/telegram-webapp/**'
      - 'Dockerfile*'
      - 'requirements*.txt'

env:
  AWS_REGION: ap-southeast-1
  PYTHON_VERSION: '3.11'

jobs:
  ###############################################################################
  # Stage 0: Determine Environment from Branch
  ###############################################################################
  environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      env_name: ${{ steps.set-env.outputs.env_name }}
      ecr_repository: ${{ steps.set-env.outputs.ecr_repository }}
      telegram_function: ${{ steps.set-env.outputs.telegram_function }}
      worker_function: ${{ steps.set-env.outputs.worker_function }}
      tfvars_file: ${{ steps.set-env.outputs.tfvars_file }}
      github_environment: ${{ steps.set-env.outputs.github_environment }}

    steps:
      - name: Set environment based on branch
        id: set-env
        run: |
          BRANCH="${GITHUB_REF_NAME}"
          echo "Branch: ${BRANCH}"

          case "${BRANCH}" in
            telegram)
              ENV_NAME="dev"
              GITHUB_ENV="development"
              ;;
            telegram-staging)
              ENV_NAME="staging"
              GITHUB_ENV="staging"
              ;;
            telegram-prod)
              ENV_NAME="prod"
              GITHUB_ENV="production"
              ;;
            *)
              echo "‚ùå Unknown branch: ${BRANCH}"
              exit 1
              ;;
          esac

          echo "üìã Environment: ${ENV_NAME}"
          echo "env_name=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "ecr_repository=dr-daily-report-lambda-${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "telegram_function=dr-daily-report-telegram-api-${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "worker_function=dr-daily-report-report-worker-${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "tfvars_file=terraform.${ENV_NAME}.tfvars" >> $GITHUB_OUTPUT
          echo "github_environment=${GITHUB_ENV}" >> $GITHUB_OUTPUT

  ###############################################################################
  # Stage 1: Quality Gates (Blocking)
  ###############################################################################
  test:
    name: Quality Gates
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements_minimal.txt
          pip install pytest pytest-asyncio pip-audit

      - name: Syntax check
        run: |
          echo "üîç Checking Python syntax..."
          python -m py_compile src/**/*.py src/api/*.py dr_cli/**/*.py
          echo "‚úÖ Syntax check passed"

      - name: Unit tests
        run: |
          echo "üß™ Running unit tests..."
          pytest tests/ -k "not integration" -v --tb=short --ignore=tests/test_smoke.py
          echo "‚úÖ Unit tests passed"

      - name: Security audit
        run: |
          echo "üîí Running security audit..."
          pip-audit --strict --desc || echo "‚ö†Ô∏è Security warnings found (non-blocking)"
        continue-on-error: true  # Don't fail on vulnerabilities in dependencies

  ###############################################################################
  # Stage 2: Build & Push to ECR
  ###############################################################################
  build:
    name: Build & Push (${{ needs.environment.outputs.env_name }})
    needs: [environment, test]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'  # Only build on push, not PR

    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      image_uri: ${{ steps.build.outputs.image_uri }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to ECR
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ needs.environment.outputs.ecr_repository }}
          ENV_NAME: ${{ needs.environment.outputs.env_name }}
        run: |
          # Generate tags
          SHA_SHORT=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${ENV_NAME}-sha-${SHA_SHORT}-${TIMESTAMP}"
          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

          echo "üì¶ Building Docker image..."
          echo "   Environment: ${ENV_NAME}"
          echo "   Repository: ${ECR_REPOSITORY}"
          echo "   Tag: ${IMAGE_TAG}"

          # Build with Lambda container image
          docker build \
            -f Dockerfile.lambda.container \
            -t ${IMAGE_URI} \
            -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:${ENV_NAME}-sha-${SHA_SHORT} \
            -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:${ENV_NAME}-latest \
            .

          echo "üöÄ Pushing to ECR..."
          docker push ${IMAGE_URI}
          docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${ENV_NAME}-sha-${SHA_SHORT}
          docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${ENV_NAME}-latest

          echo "‚úÖ Image pushed: ${IMAGE_URI}"

          # Output for next job
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build.outputs.image_uri }}
          format: 'table'
          exit-code: '0'  # Don't fail on vulnerabilities (informational)
          severity: 'CRITICAL,HIGH'

  ###############################################################################
  # Stage 3: Deploy to Lambda
  ###############################################################################
  deploy:
    name: Deploy (${{ needs.environment.outputs.env_name }})
    needs: [environment, build]
    runs-on: ubuntu-latest
    environment: ${{ needs.environment.outputs.github_environment }}

    outputs:
      telegram_api_version: ${{ steps.deploy-telegram.outputs.version }}
      worker_version: ${{ steps.deploy-worker.outputs.version }}
      previous_telegram_version: ${{ steps.get-current.outputs.telegram_version }}
      previous_worker_version: ${{ steps.get-current.outputs.worker_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current versions (for rollback)
        id: get-current
        env:
          TELEGRAM_FUNCTION: ${{ needs.environment.outputs.telegram_function }}
          WORKER_FUNCTION: ${{ needs.environment.outputs.worker_function }}
        run: |
          # Get current "live" alias versions
          TELEGRAM_VERSION=$(aws lambda get-alias \
            --function-name ${TELEGRAM_FUNCTION} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")

          WORKER_VERSION=$(aws lambda get-alias \
            --function-name ${WORKER_FUNCTION} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")

          echo "üìå Current versions:"
          echo "   Telegram API: ${TELEGRAM_VERSION}"
          echo "   Report Worker: ${WORKER_VERSION}"

          echo "telegram_version=${TELEGRAM_VERSION}" >> $GITHUB_OUTPUT
          echo "worker_version=${WORKER_VERSION}" >> $GITHUB_OUTPUT

      - name: Deploy Telegram API Lambda
        id: deploy-telegram
        env:
          IMAGE_URI: ${{ needs.build.outputs.image_uri }}
          FUNCTION_NAME: ${{ needs.environment.outputs.telegram_function }}
        run: |
          echo "üîÑ Updating ${FUNCTION_NAME}..."

          # Update function code
          aws lambda update-function-code \
            --function-name ${FUNCTION_NAME} \
            --image-uri ${IMAGE_URI} \
            --publish \
            --query 'Version' \
            --output text > version.txt

          # Wait for update to complete
          aws lambda wait function-updated --function-name ${FUNCTION_NAME}

          NEW_VERSION=$(cat version.txt)
          echo "‚úÖ Published version: ${NEW_VERSION}"

          # Update "live" alias to new version
          aws lambda update-alias \
            --function-name ${FUNCTION_NAME} \
            --name live \
            --function-version ${NEW_VERSION}

          echo "‚úÖ Alias 'live' now points to version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Deploy Report Worker Lambda
        id: deploy-worker
        env:
          IMAGE_URI: ${{ needs.build.outputs.image_uri }}
          FUNCTION_NAME: ${{ needs.environment.outputs.worker_function }}
        run: |
          echo "üîÑ Updating ${FUNCTION_NAME}..."

          # Update function code
          aws lambda update-function-code \
            --function-name ${FUNCTION_NAME} \
            --image-uri ${IMAGE_URI} \
            --publish \
            --query 'Version' \
            --output text > version.txt

          # Wait for update to complete
          aws lambda wait function-updated --function-name ${FUNCTION_NAME}

          NEW_VERSION=$(cat version.txt)
          echo "‚úÖ Published version: ${NEW_VERSION}"

          # Update "live" alias to new version
          aws lambda update-alias \
            --function-name ${FUNCTION_NAME} \
            --name live \
            --function-version ${NEW_VERSION}

          echo "‚úÖ Alias 'live' now points to version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

  ###############################################################################
  # Stage 4: Deploy Frontend
  ###############################################################################
  deploy-frontend:
    name: Deploy Frontend (${{ needs.environment.outputs.env_name }})
    needs: [environment, deploy]
    runs-on: ubuntu-latest
    environment: ${{ needs.environment.outputs.github_environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get infrastructure outputs
        id: terraform
        env:
          ENV_NAME: ${{ needs.environment.outputs.env_name }}
        run: |
          # Get values from environment-specific secrets
          # Secret names follow pattern: {SECRET_NAME}_{ENV} (e.g., WEBAPP_BUCKET_NAME_DEV)
          # Or use GitHub Environments with the same secret names
          BUCKET_NAME="${{ secrets.WEBAPP_BUCKET_NAME }}"
          API_URL="${{ secrets.TELEGRAM_API_URL }}"
          DIST_ID="${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}"

          echo "üìã Frontend config for ${ENV_NAME}:"
          echo "   Bucket: ${BUCKET_NAME}"
          echo "   API URL: ${API_URL}"

          echo "bucket_name=${BUCKET_NAME}" >> $GITHUB_OUTPUT
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
          echo "dist_id=${DIST_ID}" >> $GITHUB_OUTPUT

      - name: Prepare frontend files
        env:
          API_URL: ${{ steps.terraform.outputs.api_url }}
        run: |
          # Create build directory
          mkdir -p build

          # Copy files
          cp -r frontend/telegram-webapp/* build/

          # Inject API URL
          sed -i "s|window.TELEGRAM_API_URL = '{{API_URL}}'|window.TELEGRAM_API_URL = '${API_URL}'|g" build/index.html

          echo "‚úÖ Frontend files prepared"

      - name: Upload to S3
        env:
          BUCKET_NAME: ${{ steps.terraform.outputs.bucket_name }}
        run: |
          echo "üì§ Uploading to S3..."

          # Upload all files with default cache
          aws s3 sync build/ s3://${BUCKET_NAME}/ \
            --delete \
            --cache-control "max-age=3600" \
            --exclude "*.html"

          # Upload HTML with shorter cache
          aws s3 sync build/ s3://${BUCKET_NAME}/ \
            --exclude "*" \
            --include "*.html" \
            --cache-control "max-age=300"

          echo "‚úÖ Files uploaded to S3"

      - name: Invalidate CloudFront
        env:
          DIST_ID: ${{ steps.terraform.outputs.dist_id }}
        if: ${{ steps.terraform.outputs.dist_id != '' }}
        run: |
          echo "üîÑ Invalidating CloudFront cache..."
          aws cloudfront create-invalidation \
            --distribution-id ${DIST_ID} \
            --paths "/*" \
            --output text > /dev/null
          echo "‚úÖ CloudFront cache invalidation initiated"

  ###############################################################################
  # Stage 5: Smoke Tests & Rollback
  ###############################################################################
  smoke-test:
    name: Smoke Test (${{ needs.environment.outputs.env_name }})
    needs: [environment, build, deploy, deploy-frontend]
    runs-on: ubuntu-latest
    environment: ${{ needs.environment.outputs.github_environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install test dependencies
        run: |
          pip install requests pytest

      - name: Run smoke tests
        id: smoke
        env:
          API_URL: ${{ secrets.TELEGRAM_API_URL }}
          ENV_NAME: ${{ needs.environment.outputs.env_name }}
        run: |
          echo "üî• Running smoke tests for ${ENV_NAME} environment..."
          echo "   API URL: ${API_URL}"

          # Test 1: Health endpoint
          echo "Testing /api/v1/health..."
          HEALTH_RESPONSE=$(curl -s -w "\n%{http_code}" "${API_URL}/api/v1/health")
          HEALTH_CODE=$(echo "$HEALTH_RESPONSE" | tail -n1)

          if [ "$HEALTH_CODE" != "200" ]; then
            echo "‚ùå Health check failed with status ${HEALTH_CODE}"
            exit 1
          fi
          echo "‚úÖ Health check passed"

          # Test 2: Search endpoint
          echo "Testing /api/v1/search?q=NVDA..."
          SEARCH_RESPONSE=$(curl -s -w "\n%{http_code}" "${API_URL}/api/v1/search?q=NVDA")
          SEARCH_CODE=$(echo "$SEARCH_RESPONSE" | tail -n1)

          if [ "$SEARCH_CODE" != "200" ]; then
            echo "‚ùå Search endpoint failed with status ${SEARCH_CODE}"
            exit 1
          fi
          echo "‚úÖ Search endpoint passed"

          # Test 3: Rankings endpoint
          echo "Testing /api/v1/rankings..."
          RANKINGS_RESPONSE=$(curl -s -w "\n%{http_code}" "${API_URL}/api/v1/rankings?category=top_gainers&limit=5")
          RANKINGS_CODE=$(echo "$RANKINGS_RESPONSE" | tail -n1)

          if [ "$RANKINGS_CODE" != "200" ]; then
            echo "‚ùå Rankings endpoint failed with status ${RANKINGS_CODE}"
            exit 1
          fi
          echo "‚úÖ Rankings endpoint passed"

          echo "üéâ All smoke tests passed for ${ENV_NAME}!"

      - name: Rollback on failure
        if: failure()
        env:
          PREV_TELEGRAM_VERSION: ${{ needs.deploy.outputs.previous_telegram_version }}
          PREV_WORKER_VERSION: ${{ needs.deploy.outputs.previous_worker_version }}
          TELEGRAM_FUNCTION: ${{ needs.environment.outputs.telegram_function }}
          WORKER_FUNCTION: ${{ needs.environment.outputs.worker_function }}
          ENV_NAME: ${{ needs.environment.outputs.env_name }}
        run: |
          echo "üö® Smoke tests failed for ${ENV_NAME}! Rolling back..."

          # Rollback Telegram API
          echo "Rolling back Telegram API to version ${PREV_TELEGRAM_VERSION}..."
          aws lambda update-alias \
            --function-name ${TELEGRAM_FUNCTION} \
            --name live \
            --function-version ${PREV_TELEGRAM_VERSION}

          # Rollback Worker
          echo "Rolling back Report Worker to version ${PREV_WORKER_VERSION}..."
          aws lambda update-alias \
            --function-name ${WORKER_FUNCTION} \
            --name live \
            --function-version ${PREV_WORKER_VERSION}

          echo "‚úÖ Rollback complete for ${ENV_NAME}"
          exit 1  # Fail the workflow

  ###############################################################################
  # Notify on Success
  ###############################################################################
  notify:
    name: Notify Success (${{ needs.environment.outputs.env_name }})
    needs: [environment, build, deploy, deploy-frontend, smoke-test]
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: Deployment Summary
        env:
          ENV_NAME: ${{ needs.environment.outputs.env_name }}
          TELEGRAM_FUNCTION: ${{ needs.environment.outputs.telegram_function }}
          WORKER_FUNCTION: ${{ needs.environment.outputs.worker_function }}
        run: |
          echo "üéâ Telegram Mini App Deployment Successful!"
          echo ""
          echo "üè∑Ô∏è  Environment: ${ENV_NAME}"
          echo ""
          echo "üì¶ Backend:"
          echo "   Image: ${{ needs.build.outputs.image_tag }}"
          echo "   Telegram API Version: ${{ needs.deploy.outputs.telegram_api_version }}"
          echo "   Report Worker Version: ${{ needs.deploy.outputs.worker_version }}"
          echo ""
          echo "üåê Frontend:"
          echo "   Deployed to S3 + CloudFront"
          echo ""
          echo "Rollback commands (if needed):"
          echo "  Backend:"
          echo "    aws lambda update-alias --function-name ${TELEGRAM_FUNCTION} --name live --function-version ${{ needs.deploy.outputs.previous_telegram_version }}"
          echo "    aws lambda update-alias --function-name ${WORKER_FUNCTION} --name live --function-version ${{ needs.deploy.outputs.previous_worker_version }}"
          echo "  Frontend:"
          echo "    git checkout HEAD~1 -- frontend/telegram-webapp && ./scripts/deploy-frontend.sh ${ENV_NAME}"
