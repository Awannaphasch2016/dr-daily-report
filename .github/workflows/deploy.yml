name: Progressive Deployment Pipeline

# ============================================================================
# Progressive Deployment: dev ‚Üí staging ‚Üí prod
# Each stage must pass before the next begins
# Single trigger on telegram branch - auto-promotes through all environments
# ============================================================================
on:
  workflow_dispatch:  # Manual trigger for reruns without cached artifacts
  push:
    branches:
      - telegram  # Single trigger - auto-chains through dev ‚Üí staging ‚Üí prod
    paths:
      - 'src/**'
      - 'frontend/telegram-webapp/**'
      - 'Dockerfile*'
      - 'requirements*.txt'
      - 'terraform/**'
      - '.github/workflows/**'
  pull_request:
    branches:
      - telegram
    paths:
      - 'src/**'
      - 'frontend/telegram-webapp/**'
      - 'Dockerfile*'
      - 'requirements*.txt'

env:
  AWS_REGION: ap-southeast-1
  PYTHON_VERSION: '3.11'
  ECR_REGISTRY: 755283537543.dkr.ecr.ap-southeast-1.amazonaws.com

jobs:
  ###############################################################################
  # Stage 0: Quality Gates (runs on PR and push)
  ###############################################################################
  test:
    name: Quality Gates
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pip-audit

      - name: Syntax check
        run: |
          echo "üîç Checking Python syntax..."
          python -m py_compile src/**/*.py src/api/*.py dr_cli/**/*.py
          echo "‚úÖ Syntax check passed"

      - name: Unit tests
        run: |
          echo "üß™ Running unit tests..."
          pytest tests/shared tests/telegram -v --tb=short \
            -k "not integration and not smoke and not e2e" \
            --ignore=tests/integration/ \
            --ignore=tests/line_bot/ \
            --ignore=tests/telegram/test_e2e_frontend.py
          echo "‚úÖ Unit tests passed"

      - name: Security audit
        run: |
          echo "üîí Running security audit..."
          pip-audit --strict --desc || echo "‚ö†Ô∏è Security warnings found (non-blocking)"
        continue-on-error: true

  ###############################################################################
  # Stage 1: Build (immutable artifact - built once, promoted through envs)
  ###############################################################################
  build:
    name: Build Image
    needs: [test]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      image_uri: ${{ steps.build.outputs.image_uri }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to ECR
        id: build
        run: |
          # Generate immutable tag (no env prefix - same image for all envs)
          SHA_SHORT=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="sha-${SHA_SHORT}-${TIMESTAMP}"

          # Use dev ECR repo as the source (image is promoted, not rebuilt)
          ECR_REPOSITORY="dr-daily-report-lambda-dev"
          IMAGE_URI="${{ env.ECR_REGISTRY }}/${ECR_REPOSITORY}:${IMAGE_TAG}"

          echo "üì¶ Building Docker image..."
          echo "   Tag: ${IMAGE_TAG}"
          echo "   URI: ${IMAGE_URI}"

          docker build \
            -f Dockerfile.lambda.container \
            -t ${IMAGE_URI} \
            .

          echo "üöÄ Pushing to ECR..."
          docker push ${IMAGE_URI}

          echo "‚úÖ Image pushed: ${IMAGE_URI}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build.outputs.image_uri }}
          format: 'table'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'

  ###############################################################################
  # Stage 2: Deploy to Dev (Zero-Downtime: Test Before Promote)
  ###############################################################################
  deploy-dev:
    name: Deploy Dev
    needs: [build]
    runs-on: ubuntu-latest
    environment: development

    outputs:
      telegram_version: ${{ steps.promote-telegram.outputs.version }}
      worker_version: ${{ steps.promote-worker.outputs.version }}
      prev_telegram_version: ${{ steps.get-current.outputs.telegram_version }}
      prev_worker_version: ${{ steps.get-current.outputs.worker_version }}

    env:
      ENV_NAME: dev
      TELEGRAM_FUNCTION: dr-daily-report-telegram-api-dev
      WORKER_FUNCTION: dr-daily-report-report-worker-dev

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current versions (for rollback reference)
        id: get-current
        run: |
          TELEGRAM_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          WORKER_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          echo "üìå Current dev versions: Telegram=${TELEGRAM_VERSION}, Worker=${WORKER_VERSION}"
          echo "telegram_version=${TELEGRAM_VERSION}" >> $GITHUB_OUTPUT
          echo "worker_version=${WORKER_VERSION}" >> $GITHUB_OUTPUT

      # ========================================================================
      # Step 1: Update $LATEST (staging area - users still see old version)
      # ========================================================================
      - name: Update Telegram API to $LATEST (not live yet)
        run: |
          echo "üîÑ Uploading new code to \$LATEST (users still see old version)..."
          aws lambda update-function-code \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }}
          aws lambda wait function-updated --function-name ${{ env.TELEGRAM_FUNCTION }}
          echo "‚úÖ Code uploaded to \$LATEST"

      - name: Update Worker to $LATEST (not live yet)
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }}
          aws lambda wait function-updated --function-name ${{ env.WORKER_FUNCTION }}
          echo "‚úÖ Worker code uploaded to \$LATEST"

      # ========================================================================
      # Step 2: Smoke test $LATEST directly (before any user sees it)
      # ========================================================================
      - name: Smoke test $LATEST (pre-promotion validation)
        run: |
          echo "üß™ Testing \$LATEST directly via aws lambda invoke..."
          echo "   Users are STILL seeing the old version"

          # API Gateway HTTP API v2 event format required by Mangum
          make_payload() {
            local method=$1
            local path=$2
            local query=${3:-""}
            cat << EOF
          {"version":"2.0","routeKey":"${method} ${path}","rawPath":"${path}","rawQueryString":"${query}","headers":{"content-type":"application/json"},"requestContext":{"http":{"method":"${method}","path":"${path}","protocol":"HTTP/1.1","sourceIp":"127.0.0.1","userAgent":"smoke-test/1.0"},"requestId":"smoke-test","routeKey":"${method} ${path}","stage":"\$default"},"isBase64Encoded":false}
          EOF
          }

          # Test 1: Health endpoint
          HEALTH_PAYLOAD=$(make_payload "GET" "/api/v1/health" | base64 -w 0)
          aws lambda invoke \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --cli-read-timeout 30 \
            --payload "$HEALTH_PAYLOAD" \
            /tmp/health.json

          HEALTH_STATUS=$(cat /tmp/health.json | jq -r '.statusCode // 500')
          echo "   Health check response: ${HEALTH_STATUS}"
          if [ "$HEALTH_STATUS" != "200" ]; then
            echo "‚ùå Health check FAILED on \$LATEST"
            echo "   Response body: $(cat /tmp/health.json)"
            echo "   Users were NEVER exposed to this broken code!"
            exit 1
          fi
          echo "‚úÖ Health check passed"

          # Test 2: Search endpoint
          SEARCH_PAYLOAD=$(make_payload "GET" "/api/v1/search" "q=NVDA" | base64 -w 0)
          aws lambda invoke \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --cli-read-timeout 30 \
            --payload "$SEARCH_PAYLOAD" \
            /tmp/search.json

          SEARCH_STATUS=$(cat /tmp/search.json | jq -r '.statusCode // 500')
          echo "   Search endpoint response: ${SEARCH_STATUS}"
          if [ "$SEARCH_STATUS" != "200" ]; then
            echo "‚ùå Search endpoint FAILED on \$LATEST"
            echo "   Response body: $(cat /tmp/search.json)"
            echo "   Users were NEVER exposed to this broken code!"
            exit 1
          fi
          echo "‚úÖ Search endpoint passed"

          echo ""
          echo "üéâ All pre-promotion smoke tests PASSED!"
          echo "   Safe to promote to live alias"

      # ========================================================================
      # Step 3: Promote to live (only after tests pass)
      # ========================================================================
      - name: Promote Telegram API to live
        id: promote-telegram
        run: |
          echo "üöÄ Publishing version and updating live alias..."
          NEW_VERSION=$(aws lambda publish-version \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --query 'Version' \
            --output text)
          aws lambda update-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Dev Telegram API promoted: version ${NEW_VERSION}"
          echo "   Users now see the tested code"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Promote Worker to live
        id: promote-worker
        run: |
          NEW_VERSION=$(aws lambda publish-version \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --query 'Version' \
            --output text)
          aws lambda update-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Dev Worker promoted: version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

  ###############################################################################
  # Stage 2a: VPC Integration Tests (CodeBuild - Aurora connectivity)
  ###############################################################################
  vpc-integration-tests:
    name: VPC Integration Tests (CodeBuild)
    needs: [deploy-dev]
    runs-on: ubuntu-latest
    environment: development
    # Only run if aurora is enabled (CodeBuild project exists)
    if: ${{ vars.AURORA_ENABLED == 'true' }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Start CodeBuild for VPC tests
        id: codebuild
        run: |
          echo "üöÄ Starting CodeBuild for VPC integration tests..."
          BUILD_ID=$(aws codebuild start-build \
            --project-name dr-daily-report-vpc-tests-dev \
            --query 'build.id' \
            --output text)
          echo "build_id=${BUILD_ID}" >> $GITHUB_OUTPUT
          echo "üìã Build ID: ${BUILD_ID}"

      - name: Wait for CodeBuild completion
        run: |
          BUILD_ID="${{ steps.codebuild.outputs.build_id }}"
          echo "‚è≥ Waiting for CodeBuild to complete..."
          echo "   Build ID: ${BUILD_ID}"

          # Poll every 30 seconds for up to 20 minutes
          for i in {1..40}; do
            STATUS=$(aws codebuild batch-get-builds \
              --ids "${BUILD_ID}" \
              --query 'builds[0].buildStatus' \
              --output text)

            PHASE=$(aws codebuild batch-get-builds \
              --ids "${BUILD_ID}" \
              --query 'builds[0].currentPhase' \
              --output text 2>/dev/null || echo "UNKNOWN")

            echo "   [${i}/40] Status: ${STATUS}, Phase: ${PHASE}"

            if [ "$STATUS" = "SUCCEEDED" ]; then
              echo "‚úÖ VPC integration tests PASSED!"
              exit 0
            elif [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "FAULT" ] || [ "$STATUS" = "STOPPED" ]; then
              echo "‚ùå VPC integration tests FAILED with status: ${STATUS}"
              # Get logs URL
              LOGS_URL=$(aws codebuild batch-get-builds \
                --ids "${BUILD_ID}" \
                --query 'builds[0].logs.deepLink' \
                --output text)
              echo "üìã CloudWatch Logs: ${LOGS_URL}"
              exit 1
            fi

            sleep 30
          done

          echo "‚ùå Timeout waiting for CodeBuild (20 min limit)"
          exit 1

  ###############################################################################
  # Stage 2b: Deploy Dev Frontend (TEST CloudFront only - for E2E testing)
  ###############################################################################
  deploy-dev-frontend:
    name: Deploy Dev Frontend (TEST)
    needs: [deploy-dev]
    runs-on: ubuntu-latest
    environment: development

    outputs:
      test_url: ${{ steps.deploy.outputs.test_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy frontend to S3 + TEST CloudFront
        id: deploy
        env:
          API_URL: ${{ secrets.TELEGRAM_API_URL }}
          TEST_DIST_ID: ${{ secrets.CLOUDFRONT_TEST_DISTRIBUTION_ID }}
        run: |
          mkdir -p build
          cp -r frontend/telegram-webapp/* build/

          # Ensure API URL has /api/v1 suffix
          if [[ ! "${API_URL}" =~ /api/v1$ ]]; then
            API_URL="${API_URL%/}/api/v1"
          fi
          echo "   Using API URL: ${API_URL}"

          sed -i "s|window.TELEGRAM_API_URL = '{{API_URL}}'|window.TELEGRAM_API_URL = '${API_URL}'|g" build/index.html
          aws s3 sync build/ s3://${{ secrets.WEBAPP_BUCKET_NAME }}/ --delete
          echo "‚úÖ Dev frontend uploaded to S3"

          # Only invalidate TEST CloudFront (users still see old version)
          if [ -n "${TEST_DIST_ID}" ]; then
            aws cloudfront create-invalidation \
              --distribution-id ${TEST_DIST_ID} \
              --paths "/*" > /dev/null
            echo "‚úÖ TEST CloudFront invalidated (E2E can test new code)"
            echo "test_url=https://${{ secrets.CLOUDFRONT_TEST_DOMAIN }}" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è TEST CloudFront not configured, using APP CloudFront"
            # Fallback to APP CloudFront if TEST not configured
            if [ -n "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" ]; then
              aws cloudfront create-invalidation \
                --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
                --paths "/*" > /dev/null
            fi
            echo "test_url=https://${{ secrets.CLOUDFRONT_DOMAIN }}" >> $GITHUB_OUTPUT
          fi

  ###############################################################################
  # Stage 2c: E2E Tests against Dev TEST CloudFront
  ###############################################################################
  e2e-test-dev:
    name: E2E Tests (Dev)
    needs: [deploy-dev-frontend]
    runs-on: ubuntu-latest
    environment: development

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r requirements-dev.txt
          playwright install chromium

      - name: Run E2E Tests
        env:
          E2E_BASE_URL: ${{ needs.deploy-dev-frontend.outputs.test_url }}
        run: |
          echo "üß™ Running E2E tests against: ${E2E_BASE_URL}"
          pytest tests/e2e/ -m e2e -v --tb=short || {
            echo "‚ùå E2E tests failed! APP CloudFront will NOT be updated."
            echo "   Users still see the previous working version."
            exit 1
          }
          echo "‚úÖ E2E tests passed!"

  ###############################################################################
  # Stage 2d: Promote Dev Frontend (APP CloudFront - users see new version)
  ###############################################################################
  promote-dev-frontend:
    name: Promote Dev Frontend (APP)
    needs: [e2e-test-dev]
    runs-on: ubuntu-latest
    environment: development

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Invalidate APP CloudFront (users see new frontend)
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          if [ -n "${DIST_ID}" ]; then
            aws cloudfront create-invalidation \
              --distribution-id ${DIST_ID} \
              --paths "/*" > /dev/null
            echo "‚úÖ APP CloudFront invalidated - users now see new frontend"
          else
            echo "‚è≠Ô∏è No APP CloudFront distribution configured"
          fi

  ###############################################################################
  # Stage 3: Deploy to Staging (Zero-Downtime: Test Before Promote)
  ###############################################################################
  deploy-staging:
    name: Deploy Staging
    needs: [build, promote-dev-frontend]  # Waits for dev E2E tests to pass
    runs-on: ubuntu-latest
    environment: staging

    outputs:
      telegram_version: ${{ steps.promote-telegram.outputs.version }}
      worker_version: ${{ steps.promote-worker.outputs.version }}
      prev_telegram_version: ${{ steps.get-current.outputs.telegram_version }}
      prev_worker_version: ${{ steps.get-current.outputs.worker_version }}

    env:
      ENV_NAME: staging
      TELEGRAM_FUNCTION: dr-daily-report-telegram-api-staging
      WORKER_FUNCTION: dr-daily-report-report-worker-staging

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current versions (for rollback reference)
        id: get-current
        run: |
          TELEGRAM_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          WORKER_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          echo "üìå Current staging versions: Telegram=${TELEGRAM_VERSION}, Worker=${WORKER_VERSION}"
          echo "telegram_version=${TELEGRAM_VERSION}" >> $GITHUB_OUTPUT
          echo "worker_version=${WORKER_VERSION}" >> $GITHUB_OUTPUT

      # ========================================================================
      # Step 1: Update $LATEST (staging area - users still see old version)
      # ========================================================================
      - name: Update Telegram API to $LATEST (not live yet)
        run: |
          echo "üîÑ Uploading new code to \$LATEST (users still see old version)..."
          aws lambda update-function-code \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }}
          aws lambda wait function-updated --function-name ${{ env.TELEGRAM_FUNCTION }}
          echo "‚úÖ Code uploaded to \$LATEST"

      - name: Update Worker to $LATEST (not live yet)
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }}
          aws lambda wait function-updated --function-name ${{ env.WORKER_FUNCTION }}
          echo "‚úÖ Worker code uploaded to \$LATEST"

      # ========================================================================
      # Step 2: Smoke test $LATEST directly (before any user sees it)
      # ========================================================================
      - name: Smoke test $LATEST (pre-promotion validation)
        run: |
          echo "üß™ Testing \$LATEST directly via aws lambda invoke..."
          echo "   Users are STILL seeing the old version"

          # API Gateway HTTP API v2 event format required by Mangum
          make_payload() {
            local method=$1
            local path=$2
            local query=${3:-""}
            cat << EOF
          {"version":"2.0","routeKey":"${method} ${path}","rawPath":"${path}","rawQueryString":"${query}","headers":{"content-type":"application/json"},"requestContext":{"http":{"method":"${method}","path":"${path}","protocol":"HTTP/1.1","sourceIp":"127.0.0.1","userAgent":"smoke-test/1.0"},"requestId":"smoke-test","routeKey":"${method} ${path}","stage":"\$default"},"isBase64Encoded":false}
          EOF
          }

          # Test 1: Health endpoint
          HEALTH_PAYLOAD=$(make_payload "GET" "/api/v1/health" | base64 -w 0)
          aws lambda invoke \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --cli-read-timeout 30 \
            --payload "$HEALTH_PAYLOAD" \
            /tmp/health.json

          HEALTH_STATUS=$(cat /tmp/health.json | jq -r '.statusCode // 500')
          echo "   Health check response: ${HEALTH_STATUS}"
          if [ "$HEALTH_STATUS" != "200" ]; then
            echo "‚ùå Health check FAILED on \$LATEST"
            echo "   Response body: $(cat /tmp/health.json)"
            echo "   Users were NEVER exposed to this broken code!"
            exit 1
          fi
          echo "‚úÖ Health check passed"

          # Test 2: Search endpoint
          SEARCH_PAYLOAD=$(make_payload "GET" "/api/v1/search" "q=NVDA" | base64 -w 0)
          aws lambda invoke \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --cli-read-timeout 30 \
            --payload "$SEARCH_PAYLOAD" \
            /tmp/search.json

          SEARCH_STATUS=$(cat /tmp/search.json | jq -r '.statusCode // 500')
          echo "   Search endpoint response: ${SEARCH_STATUS}"
          if [ "$SEARCH_STATUS" != "200" ]; then
            echo "‚ùå Search endpoint FAILED on \$LATEST"
            echo "   Response body: $(cat /tmp/search.json)"
            echo "   Users were NEVER exposed to this broken code!"
            exit 1
          fi
          echo "‚úÖ Search endpoint passed"

          echo ""
          echo "üéâ All pre-promotion smoke tests PASSED!"
          echo "   Safe to promote to live alias"

      # ========================================================================
      # Step 3: Promote to live (only after tests pass)
      # ========================================================================
      - name: Promote Telegram API to live
        id: promote-telegram
        run: |
          echo "üöÄ Publishing version and updating live alias..."
          NEW_VERSION=$(aws lambda publish-version \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --query 'Version' \
            --output text)
          aws lambda update-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Staging Telegram API promoted: version ${NEW_VERSION}"
          echo "   Users now see the tested code"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Promote Worker to live
        id: promote-worker
        run: |
          NEW_VERSION=$(aws lambda publish-version \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --query 'Version' \
            --output text)
          aws lambda update-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Staging Worker promoted: version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

  ###############################################################################
  # Stage 3b: Deploy Staging Frontend (TEST CloudFront only - for E2E testing)
  ###############################################################################
  deploy-staging-frontend:
    name: Deploy Staging Frontend (TEST)
    needs: [deploy-staging]
    runs-on: ubuntu-latest
    environment: staging

    outputs:
      test_url: ${{ steps.deploy.outputs.test_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy frontend to S3 + TEST CloudFront
        id: deploy
        env:
          API_URL: ${{ secrets.TELEGRAM_API_URL }}
          TEST_DIST_ID: ${{ secrets.CLOUDFRONT_TEST_DISTRIBUTION_ID }}
        run: |
          mkdir -p build
          cp -r frontend/telegram-webapp/* build/

          # Ensure API URL has /api/v1 suffix
          if [[ ! "${API_URL}" =~ /api/v1$ ]]; then
            API_URL="${API_URL%/}/api/v1"
          fi
          echo "   Using API URL: ${API_URL}"

          sed -i "s|window.TELEGRAM_API_URL = '{{API_URL}}'|window.TELEGRAM_API_URL = '${API_URL}'|g" build/index.html
          aws s3 sync build/ s3://${{ secrets.WEBAPP_BUCKET_NAME }}/ --delete
          echo "‚úÖ Staging frontend uploaded to S3"

          # Only invalidate TEST CloudFront (users still see old version)
          if [ -n "${TEST_DIST_ID}" ]; then
            aws cloudfront create-invalidation \
              --distribution-id ${TEST_DIST_ID} \
              --paths "/*" > /dev/null
            echo "‚úÖ TEST CloudFront invalidated (E2E can test new code)"
            echo "test_url=https://${{ secrets.CLOUDFRONT_TEST_DOMAIN }}" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è TEST CloudFront not configured, using APP CloudFront"
            if [ -n "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" ]; then
              aws cloudfront create-invalidation \
                --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
                --paths "/*" > /dev/null
            fi
            echo "test_url=https://${{ secrets.CLOUDFRONT_DOMAIN }}" >> $GITHUB_OUTPUT
          fi

  ###############################################################################
  # Stage 3c: E2E Tests against Staging TEST CloudFront
  ###############################################################################
  e2e-test-staging:
    name: E2E Tests (Staging)
    needs: [deploy-staging-frontend]
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r requirements-dev.txt
          playwright install chromium

      - name: Run E2E Tests
        env:
          E2E_BASE_URL: ${{ needs.deploy-staging-frontend.outputs.test_url }}
        run: |
          echo "üß™ Running E2E tests against: ${E2E_BASE_URL}"
          pytest tests/e2e/ -m e2e -v --tb=short || {
            echo "‚ùå E2E tests failed! APP CloudFront will NOT be updated."
            echo "   Users still see the previous working version."
            exit 1
          }
          echo "‚úÖ E2E tests passed!"

  ###############################################################################
  # Stage 3d: Promote Staging Frontend (APP CloudFront - users see new version)
  ###############################################################################
  promote-staging-frontend:
    name: Promote Staging Frontend (APP)
    needs: [e2e-test-staging]
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Invalidate APP CloudFront (users see new frontend)
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          if [ -n "${DIST_ID}" ]; then
            aws cloudfront create-invalidation \
              --distribution-id ${DIST_ID} \
              --paths "/*" > /dev/null
            echo "‚úÖ APP CloudFront invalidated - users now see new frontend"
          else
            echo "‚è≠Ô∏è No APP CloudFront distribution configured"
          fi

  ###############################################################################
  # Stage 4: Deploy to Prod (Zero-Downtime: Test Before Promote)
  ###############################################################################
  deploy-prod:
    name: Deploy Prod
    needs: [build, promote-staging-frontend]  # Waits for staging E2E tests to pass
    runs-on: ubuntu-latest
    environment: production

    outputs:
      telegram_version: ${{ steps.promote-telegram.outputs.version }}
      worker_version: ${{ steps.promote-worker.outputs.version }}
      prev_telegram_version: ${{ steps.get-current.outputs.telegram_version }}
      prev_worker_version: ${{ steps.get-current.outputs.worker_version }}

    env:
      ENV_NAME: prod
      TELEGRAM_FUNCTION: dr-daily-report-telegram-api-prod
      WORKER_FUNCTION: dr-daily-report-report-worker-prod

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check if prod Lambda exists
        id: check-lambda
        run: |
          if aws lambda get-function --function-name ${{ env.TELEGRAM_FUNCTION }} 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Prod Lambda ${{ env.TELEGRAM_FUNCTION }} doesn't exist - skipping deployment"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Get current versions (for rollback reference)
        id: get-current
        if: steps.check-lambda.outputs.exists == 'true'
        run: |
          TELEGRAM_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          WORKER_VERSION=$(aws lambda get-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")
          echo "üìå Current prod versions: Telegram=${TELEGRAM_VERSION}, Worker=${WORKER_VERSION}"
          echo "telegram_version=${TELEGRAM_VERSION}" >> $GITHUB_OUTPUT
          echo "worker_version=${WORKER_VERSION}" >> $GITHUB_OUTPUT

      # ========================================================================
      # Step 1: Update $LATEST (staging area - users still see old version)
      # ========================================================================
      - name: Update Telegram API to $LATEST (not live yet)
        if: steps.check-lambda.outputs.exists == 'true'
        run: |
          echo "üîÑ Uploading new code to \$LATEST (users still see old version)..."
          aws lambda update-function-code \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }}
          aws lambda wait function-updated --function-name ${{ env.TELEGRAM_FUNCTION }}
          echo "‚úÖ Code uploaded to \$LATEST"

      - name: Update Worker to $LATEST (not live yet)
        if: steps.check-lambda.outputs.exists == 'true'
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --image-uri ${{ needs.build.outputs.image_uri }}
          aws lambda wait function-updated --function-name ${{ env.WORKER_FUNCTION }}
          echo "‚úÖ Worker code uploaded to \$LATEST"

      # ========================================================================
      # Step 2: Smoke test $LATEST directly (before any user sees it)
      # ========================================================================
      - name: Smoke test $LATEST (pre-promotion validation)
        if: steps.check-lambda.outputs.exists == 'true'
        run: |
          echo "üß™ Testing \$LATEST directly via aws lambda invoke..."
          echo "   Users are STILL seeing the old version"

          # API Gateway HTTP API v2 event format required by Mangum
          make_payload() {
            local method=$1
            local path=$2
            local query=${3:-""}
            cat << EOF
          {"version":"2.0","routeKey":"${method} ${path}","rawPath":"${path}","rawQueryString":"${query}","headers":{"content-type":"application/json"},"requestContext":{"http":{"method":"${method}","path":"${path}","protocol":"HTTP/1.1","sourceIp":"127.0.0.1","userAgent":"smoke-test/1.0"},"requestId":"smoke-test","routeKey":"${method} ${path}","stage":"\$default"},"isBase64Encoded":false}
          EOF
          }

          # Test 1: Health endpoint
          HEALTH_PAYLOAD=$(make_payload "GET" "/api/v1/health" | base64 -w 0)
          aws lambda invoke \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --cli-read-timeout 30 \
            --payload "$HEALTH_PAYLOAD" \
            /tmp/health.json

          HEALTH_STATUS=$(cat /tmp/health.json | jq -r '.statusCode // 500')
          echo "   Health check response: ${HEALTH_STATUS}"
          if [ "$HEALTH_STATUS" != "200" ]; then
            echo "‚ùå Health check FAILED on \$LATEST"
            echo "   Response body: $(cat /tmp/health.json)"
            echo "   Users were NEVER exposed to this broken code!"
            exit 1
          fi
          echo "‚úÖ Health check passed"

          # Test 2: Search endpoint
          SEARCH_PAYLOAD=$(make_payload "GET" "/api/v1/search" "q=NVDA" | base64 -w 0)
          aws lambda invoke \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --cli-read-timeout 30 \
            --payload "$SEARCH_PAYLOAD" \
            /tmp/search.json

          SEARCH_STATUS=$(cat /tmp/search.json | jq -r '.statusCode // 500')
          echo "   Search endpoint response: ${SEARCH_STATUS}"
          if [ "$SEARCH_STATUS" != "200" ]; then
            echo "‚ùå Search endpoint FAILED on \$LATEST"
            echo "   Response body: $(cat /tmp/search.json)"
            echo "   Users were NEVER exposed to this broken code!"
            exit 1
          fi
          echo "‚úÖ Search endpoint passed"

          echo ""
          echo "üéâ All pre-promotion smoke tests PASSED!"
          echo "   Safe to promote to live alias"

      # ========================================================================
      # Step 3: Promote to live (only after tests pass)
      # ========================================================================
      - name: Promote Telegram API to live
        id: promote-telegram
        if: steps.check-lambda.outputs.exists == 'true'
        run: |
          echo "üöÄ Publishing version and updating live alias..."
          NEW_VERSION=$(aws lambda publish-version \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --query 'Version' \
            --output text)
          aws lambda update-alias \
            --function-name ${{ env.TELEGRAM_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Prod Telegram API promoted: version ${NEW_VERSION}"
          echo "   Users now see the tested code"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Promote Worker to live
        id: promote-worker
        if: steps.check-lambda.outputs.exists == 'true'
        run: |
          NEW_VERSION=$(aws lambda publish-version \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --query 'Version' \
            --output text)
          aws lambda update-alias \
            --function-name ${{ env.WORKER_FUNCTION }} \
            --name live \
            --function-version ${NEW_VERSION}
          echo "‚úÖ Prod Worker promoted: version ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

  ###############################################################################
  # Stage 4b: Deploy Prod Frontend (TEST CloudFront only - for E2E testing)
  ###############################################################################
  deploy-prod-frontend:
    name: Deploy Prod Frontend (TEST)
    needs: [deploy-prod]
    runs-on: ubuntu-latest
    environment: production

    outputs:
      test_url: ${{ steps.deploy.outputs.test_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy frontend to S3 + TEST CloudFront
        id: deploy
        env:
          BUCKET_NAME: ${{ secrets.WEBAPP_BUCKET_NAME }}
          API_URL: ${{ secrets.TELEGRAM_API_URL }}
          TEST_DIST_ID: ${{ secrets.CLOUDFRONT_TEST_DISTRIBUTION_ID }}
        run: |
          # Skip if no bucket configured (prod not set up)
          if [ -z "${BUCKET_NAME}" ]; then
            echo "‚ö†Ô∏è No WEBAPP_BUCKET_NAME configured for production - skipping frontend deployment"
            exit 0
          fi
          mkdir -p build
          cp -r frontend/telegram-webapp/* build/

          # Ensure API URL has /api/v1 suffix
          if [[ ! "${API_URL}" =~ /api/v1$ ]]; then
            API_URL="${API_URL%/}/api/v1"
          fi
          echo "   Using API URL: ${API_URL}"

          sed -i "s|window.TELEGRAM_API_URL = '{{API_URL}}'|window.TELEGRAM_API_URL = '${API_URL}'|g" build/index.html
          aws s3 sync build/ s3://${BUCKET_NAME}/ --delete
          echo "‚úÖ Prod frontend uploaded to S3"

          # Only invalidate TEST CloudFront (users still see old version)
          if [ -n "${TEST_DIST_ID}" ]; then
            aws cloudfront create-invalidation \
              --distribution-id ${TEST_DIST_ID} \
              --paths "/*" > /dev/null
            echo "‚úÖ TEST CloudFront invalidated (E2E can test new code)"
            echo "test_url=https://${{ secrets.CLOUDFRONT_TEST_DOMAIN }}" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è TEST CloudFront not configured, using APP CloudFront"
            if [ -n "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" ]; then
              aws cloudfront create-invalidation \
                --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
                --paths "/*" > /dev/null
            fi
            echo "test_url=https://${{ secrets.CLOUDFRONT_DOMAIN }}" >> $GITHUB_OUTPUT
          fi

  ###############################################################################
  # Stage 4c: E2E Tests against Prod TEST CloudFront
  ###############################################################################
  e2e-test-prod:
    name: E2E Tests (Prod)
    needs: [deploy-prod-frontend]
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install pytest playwright pytest-playwright
          playwright install chromium

      - name: Run E2E Tests
        env:
          E2E_BASE_URL: ${{ needs.deploy-prod-frontend.outputs.test_url }}
        run: |
          # Skip if no test URL (prod not set up)
          if [ -z "${E2E_BASE_URL}" ]; then
            echo "‚ö†Ô∏è No test URL available - skipping E2E tests"
            exit 0
          fi
          echo "üß™ Running E2E tests against: ${E2E_BASE_URL}"
          pytest tests/e2e/ -m e2e -v --tb=short || {
            echo "‚ùå E2E tests failed! APP CloudFront will NOT be updated."
            echo "   Users still see the previous working version."
            exit 1
          }
          echo "‚úÖ E2E tests passed!"

  ###############################################################################
  # Stage 4d: Promote Prod Frontend (APP CloudFront - users see new version)
  ###############################################################################
  promote-prod-frontend:
    name: Promote Prod Frontend (APP)
    needs: [e2e-test-prod]
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Invalidate APP CloudFront (users see new frontend)
        env:
          DIST_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          if [ -n "${DIST_ID}" ]; then
            aws cloudfront create-invalidation \
              --distribution-id ${DIST_ID} \
              --paths "/*" > /dev/null
            echo "‚úÖ APP CloudFront invalidated - users now see new frontend"
          else
            echo "‚è≠Ô∏è No APP CloudFront distribution configured"
          fi

  ###############################################################################
  # Final: Deployment Summary
  ###############################################################################
  notify:
    name: Deployment Complete
    needs: [build, deploy-dev, vpc-integration-tests, promote-dev-frontend, deploy-staging, promote-staging-frontend, deploy-prod, promote-prod-frontend]
    runs-on: ubuntu-latest
    if: always() && !cancelled() && !contains(needs.*.result, 'failure')

    steps:
      - name: Deployment Summary
        run: |
          echo "üéâ Zero-Downtime Progressive Deployment Complete!"
          echo ""
          echo "üì¶ Image: ${{ needs.build.outputs.image_tag }}"
          echo ""
          echo "üè∑Ô∏è  Deployed to all environments (pre-promotion smoke tested):"
          echo "   ‚úÖ Dev:     Telegram v${{ needs.deploy-dev.outputs.telegram_version }}, Worker v${{ needs.deploy-dev.outputs.worker_version }}"
          echo "   ‚úÖ Staging: Telegram v${{ needs.deploy-staging.outputs.telegram_version }}, Worker v${{ needs.deploy-staging.outputs.worker_version }}"
          echo "   ‚úÖ Prod:    Telegram v${{ needs.deploy-prod.outputs.telegram_version }}, Worker v${{ needs.deploy-prod.outputs.worker_version }}"
          echo ""
          echo "üõ°Ô∏è  Zero-Downtime Pattern: Test Before Promote"
          echo ""
          echo "   Backend (Lambda):"
          echo "   ‚Ä¢ Code uploaded to \$LATEST (staging area)"
          echo "   ‚Ä¢ Smoke tested via aws lambda invoke"
          echo "   ‚Ä¢ Only promoted to live alias after tests pass"
          echo ""
          echo "   VPC Integration Tests (CodeBuild):"
          echo "   ‚Ä¢ Aurora connectivity tested inside VPC"
          echo "   ‚Ä¢ Cache-first behavior verified with fixtures"
          echo "   ‚Ä¢ Tests: ${{ needs.vpc-integration-tests.result || 'skipped' }}"
          echo ""
          echo "   Frontend (CloudFront):"
          echo "   ‚Ä¢ Files uploaded to S3 bucket"
          echo "   ‚Ä¢ TEST CloudFront invalidated ‚Üí E2E tests run"
          echo "   ‚Ä¢ APP CloudFront invalidated ONLY after E2E pass"
          echo ""
          echo "   Users NEVER saw untested code (backend or frontend)!"

