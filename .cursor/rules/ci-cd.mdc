---
description: Auto-progressive deployment through GitHub Actions. Use when working with CI/CD pipelines or GitHub Actions workflows.
globs: [".github/workflows/**"]
alwaysApply: false
---

# CI/CD Architecture

Auto-progressive deployment through GitHub Actions.

---

## Pipeline Overview

**Single branch triggers deployment to ALL environments:**

```yaml
on:
  push:
    branches:
      - telegram  # Only trigger - auto-chains dev → staging → prod
    paths:
      - 'src/**'
      - 'frontend/telegram-webapp/**'
      - 'Dockerfile*'
      - 'requirements*.txt'
      - 'terraform/**'
```

---

## Path Filters - What Triggers Deployment

| File Change | Triggers Deploy? | Why |
|-------------|------------------|-----|
| `src/*.py` | ✅ Yes | Backend code changes |
| `frontend/telegram-webapp/*.js` | ✅ Yes | Frontend code changes |
| `Dockerfile*` | ✅ Yes | Container config changes |
| `requirements*.txt` | ✅ Yes | Dependencies changed |
| `terraform/**` | ✅ Yes | Infrastructure changes |
| `tests/*.py` | ❌ No | Tests don't affect production |
| `docs/*.md` | ❌ No | Documentation is git-only |
| `.claude/CLAUDE.md` | ❌ No | Dev instructions, not runtime |
| `.github/workflows/*.yml` | ❌ No | CI config (runs on next trigger) |

**To force deployment without code changes:**
```bash
# Add trivial change to a path-filtered file
echo "# $(date)" >> src/config.py
git commit -m "chore: trigger deployment"
git push origin telegram
```

---

## Pipeline Flow

```
git push origin telegram
       ↓
┌──────────────────┐
│   Quality Gates  │  Unit tests, syntax check, security audit
└────────┬─────────┘
         ↓
┌──────────────────┐
│   Build Image    │  Docker build → ECR (one image for all envs)
└────────┬─────────┘
         ↓
┌──────────────────┐
│   Deploy Dev     │  update-function-code → smoke test → promote
└────────┬─────────┘
         ↓ (only if dev succeeds)
┌──────────────────┐
│  Deploy Staging  │  update-function-code → smoke test → promote
└────────┬─────────┘
         ↓ (only if staging succeeds)
┌──────────────────┐
│   Deploy Prod    │  update-function-code → smoke test → promote
└──────────────────┘
```

**Key Points:**
- NO terraform in CI/CD (infrastructure assumed to exist)
- Same Docker image promoted through all environments
- Zero-downtime: test $LATEST before updating "live" alias
- Auto-progressive: no manual gates between environments

---

## Deployment Jobs

### 1. Quality Gates

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run tests
        run: pytest --tier=1  # Deploy gate tests only

      - name: Security audit
        run: |
          pip install safety
          safety check
```

### 2. Build & Push Image

```yaml
  build:
    needs: test
    runs-on: ubuntu-latest
    outputs:
      image_uri: ${{ steps.build.outputs.image_uri }}

    steps:
      - name: Build Docker image
        id: build
        run: |
          TAG="sha-${GITHUB_SHA::7}-$(date '+%Y%m%d-%H%M%S')"
          docker build -t $ECR_REPO:$TAG -f Dockerfile.lambda.container .
          docker push $ECR_REPO:$TAG
          echo "image_uri=$ECR_REPO:$TAG" >> $GITHUB_OUTPUT
```

**Why SHA-based tags:**
- Immutable: can't be overwritten
- Traceable: links deployment to exact commit
- Promotable: same image through all envs

### 3. Deploy to Dev

```yaml
  deploy-dev:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Update Lambda function
        run: |
          aws lambda update-function-code \
            --function-name dr-daily-report-telegram-api-dev \
            --image-uri ${{ needs.build.outputs.image_uri }}

      - name: Wait for update (CRITICAL)
        run: |
          aws lambda wait function-updated \
            --function-name dr-daily-report-telegram-api-dev

      - name: Smoke test $LATEST
        run: |
          aws lambda invoke \
            --function-name dr-daily-report-telegram-api-dev \
            --qualifier '$LATEST' \
            --payload '{"httpMethod": "GET", "path": "/api/v1/health"}' \
            /tmp/smoke-test.json

          if ! grep -q '"statusCode":200' /tmp/smoke-test.json; then
            echo "Smoke test failed!"
            cat /tmp/smoke-test.json
            exit 1
          fi

      - name: Publish version
        id: publish
        run: |
          VERSION=$(aws lambda publish-version \
            --function-name dr-daily-report-telegram-api-dev \
            --query 'Version' \
            --output text)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update 'live' alias
        run: |
          aws lambda update-alias \
            --function-name dr-daily-report-telegram-api-dev \
            --name live \
            --function-version ${{ steps.publish.outputs.version }}
```

### 4. Deploy to Staging

```yaml
  deploy-staging:
    needs: [build, deploy-dev]  # Only runs if dev succeeds
    runs-on: ubuntu-latest
    # Same steps as deploy-dev, but for staging environment
```

### 5. Deploy to Prod

```yaml
  deploy-prod:
    needs: [build, deploy-staging]  # Only runs if staging succeeds
    runs-on: ubuntu-latest
    # Same steps as deploy-staging, but for prod environment
```

---

## Monitoring Deployment

**GitHub Actions monitoring:**
```bash
# Watch deployment in real-time
gh run watch --exit-status

# Check specific run
gh run view 12345 --json conclusion
# → {"conclusion": "success"}  # BOTH status AND conclusion matter!

# Get logs if failed
gh run view 12345 --log-failed
```

**Critical: Check BOTH status and conclusion:**
```
status: completed  = "The workflow finished running"
conclusion: success = "The workflow achieved its goal"

A workflow can be:
- completed + success → ✅ Deploy succeeded
- completed + failure → ❌ Deploy failed
- completed + cancelled → ⚠️ Someone cancelled it
```

---

## Artifact Promotion Principle

**Build once, promote same immutable image through all environments:**

```
Docker Image: sha-abc123-20251127 (IMMUTABLE)
     │
     ├──▶  DEV:     Uses sha-abc123-20251127
     │              (auto on push to telegram)
     │
     ├──▶  STAGING: Uses sha-abc123-20251127
     │              (same image, after dev succeeds)
     │
     └──▶  PROD:    Uses sha-abc123-20251127
                    (same image, after staging succeeds)
```

**Why this matters:**
- What you test in staging is EXACTLY what deploys to prod
- No "works in staging, fails in prod" surprises
- Fast rollback (just point alias back)

---

## Environment Variables (GitHub Secrets)

**Required per environment:**
- `AWS_ACCESS_KEY_ID` - Deployment user credentials
- `AWS_SECRET_ACCESS_KEY` - Deployment user secret
- `AWS_REGION` - ap-southeast-1
- `CLOUDFRONT_DISTRIBUTION_ID` - APP CloudFront ID
- `CLOUDFRONT_TEST_DISTRIBUTION_ID` - TEST CloudFront ID

**How to set:**
```bash
# Via GitHub CLI
gh secret set AWS_ACCESS_KEY_ID --body "$ACCESS_KEY"
gh secret set AWS_SECRET_ACCESS_KEY --body "$SECRET_KEY"

# Via GitHub UI
# Settings → Secrets → Actions → New repository secret
```

---

## Rollback in CI/CD

If production deploy fails, manually rollback:

```bash
# 1. Find previous working version
aws lambda list-versions-by-function \
  --function-name dr-daily-report-telegram-api-prod \
  --max-items 5

# 2. Update alias to previous version
aws lambda update-alias \
  --function-name dr-daily-report-telegram-api-prod \
  --name live \
  --function-version <previous-version>
```

**Future improvement:** Add automatic rollback on smoke test failure.

---

## See Also

- [Lambda Versioning](LAMBDA_VERSIONING.md) - Zero-downtime pattern
- [Deployment Workflow](WORKFLOW.md) - Manual deployment process
- [Monitoring Guide](MONITORING.md) - Proper waiter usage
