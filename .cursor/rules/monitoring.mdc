---
description: Proper monitoring patterns for AWS and GitHub Actions deployments. Use when monitoring deployments or debugging issues.
globs: ["scripts/deploy*.sh", ".github/workflows/**"]
alwaysApply: false
---

# Deployment Monitoring Guide

Proper monitoring patterns for AWS and GitHub Actions deployments.

---

## AWS CLI Waiters - The Blocking Pattern

**CRITICAL: Never use `sleep X` to wait for AWS operations.**

### Why Waiters Matter

Time-based waiting leads to incorrect conclusions:
- **Too short**: Conclude "bug exists" when deployment isn't done yet
- **Too long**: Waste time waiting for already-completed operations
- **Variable**: Same operation takes different time based on load/complexity

### Lambda Waiters

```bash
# Pattern: Update ‚Üí Wait ‚Üí Test ‚Üí Promote

# 1. Update function code
aws lambda update-function-code \
  --function-name dr-daily-report-telegram-api-dev \
  --image-uri $ECR_REPO:$TAG

# 2. Wait for update (CRITICAL - blocks until done)
aws lambda wait function-updated \
  --function-name dr-daily-report-telegram-api-dev

# 3. Now safe to test (Lambda is ACTUALLY updated)
aws lambda invoke \
  --function-name dr-daily-report-telegram-api-dev \
  --qualifier '$LATEST' \
  --payload '{"httpMethod": "GET", "path": "/api/v1/health"}' \
  /tmp/smoke-test.json
```

**Anti-Pattern:**
```bash
# WRONG: Time-based waiting
aws lambda update-function-code ...
sleep 60  # ‚ùå Might not be ready, or wastes time

# RIGHT: Use waiter
aws lambda update-function-code ...
aws lambda wait function-updated --function-name $FUNC  # ‚úÖ Blocks until done
```

### CloudFront Waiters

```bash
# Create invalidation
INVALIDATION_ID=$(aws cloudfront create-invalidation \
  --distribution-id $DIST_ID \
  --paths "/*" \
  --query 'Invalidation.Id' \
  --output text)

# Wait for completion (CRITICAL)
aws cloudfront wait invalidation-completed \
  --distribution-id $DIST_ID \
  --id $INVALIDATION_ID

# Now CloudFront ACTUALLY serves new files
echo "‚úÖ Cache invalidated, new files live"
```

### Available AWS Waiters

| Service | Waiter | Command |
|---------|--------|---------|
| Lambda | Function updated | `aws lambda wait function-updated --function-name X` |
| Lambda | Function active | `aws lambda wait function-active --function-name X` |
| Lambda | Function exists | `aws lambda wait function-exists --function-name X` |
| CloudFront | Invalidation completed | `aws cloudfront wait invalidation-completed --distribution-id X --id Y` |
| CloudFront | Distribution deployed | `aws cloudfront wait distribution-deployed --id X` |
| DynamoDB | Table exists | `aws dynamodb wait table-exists --table-name X` |
| API Gateway | API deployed | `aws apigatewayv2 wait deployment-completed --api-id X` |

---

## GitHub Actions Monitoring

### The `gh run watch` Pattern

**CRITICAL: Use `--exit-status` to get proper exit codes.**

```bash
# Correct: Watch with exit status (blocks until done)
gh run watch --exit-status

# Or for specific run
gh run watch 12345 --exit-status
```

**Why `--exit-status` matters:**
- Without it: `gh run watch` always exits 0 (even if workflow failed)
- With it: Returns non-zero exit code if workflow fails
- CI/CD scripts can properly detect failures

### Checking Workflow Status

**CRITICAL: Check BOTH `status` and `conclusion`.**

```bash
# Check specific run
gh run view 12345 --json status,conclusion --jq '{status, conclusion}'

# Output examples:
# {"status": "completed", "conclusion": "success"}  ‚Üí ‚úÖ Deploy succeeded
# {"status": "completed", "conclusion": "failure"}  ‚Üí ‚ùå Deploy failed
# {"status": "completed", "conclusion": "cancelled"} ‚Üí ‚ö†Ô∏è Someone cancelled it
# {"status": "in_progress", "conclusion": null}     ‚Üí ‚è≥ Still running
```

**Completion vs Success - The Critical Distinction:**

| Status | Conclusion | Meaning |
|--------|------------|---------|
| `completed` | `success` | ‚úÖ Workflow achieved its goal |
| `completed` | `failure` | ‚ùå Workflow finished but failed (tests failed, build error, etc.) |
| `completed` | `cancelled` | ‚ö†Ô∏è Someone manually cancelled the workflow |
| `in_progress` | `null` | ‚è≥ Workflow still running |

**Anti-Pattern:**
```bash
# WRONG: Only checking status
gh run view 12345 --json status
# {"status": "completed"}  ‚Üê This does NOT mean success!

# RIGHT: Check both status AND conclusion
gh run view 12345 --json status,conclusion
# {"status": "completed", "conclusion": "success"}  ‚Üê Now we know it worked
```

### Monitoring in Real-Time

```bash
# Watch deployment in real-time
gh run watch --exit-status

# Get logs if failed
gh run view 12345 --log-failed

# Check latest run status
gh run list --limit 1 --json status,conclusion,databaseId
```

### CI/CD Script Pattern

```bash
#!/bin/bash
set -euo pipefail

# Trigger deployment
git push origin telegram

# Get latest run ID
RUN_ID=$(gh run list --limit 1 --json databaseId --jq '.[0].databaseId')

# Watch with proper exit handling
echo "üöÄ Monitoring deployment (Run ID: $RUN_ID)..."
if gh run watch $RUN_ID --exit-status; then
  echo "‚úÖ Deployment succeeded!"
  exit 0
else
  echo "‚ùå Deployment failed!"
  echo "Fetching failed logs..."
  gh run view $RUN_ID --log-failed | tail -100
  exit 1
fi
```

---

## Lambda Monitoring

### CloudWatch Logs Streaming

```bash
# Tail logs in real-time
aws logs tail /aws/lambda/dr-daily-report-telegram-api-dev --follow

# Filter for errors only
aws logs tail /aws/lambda/dr-daily-report-telegram-api-dev \
  --follow \
  --filter-pattern "ERROR"

# Tail from specific time
aws logs tail /aws/lambda/dr-daily-report-telegram-api-dev \
  --since 5m \
  --follow
```

### Getting Specific Log Streams

```bash
# List recent log streams
aws logs describe-log-streams \
  --log-group-name /aws/lambda/dr-daily-report-telegram-api-dev \
  --order-by LastEventTime \
  --descending \
  --max-items 5

# Get logs from specific stream
LOG_STREAM='2025/12/07/[$LATEST]abc123'
aws logs get-log-events \
  --log-group-name /aws/lambda/dr-daily-report-telegram-api-dev \
  --log-stream-name "$LOG_STREAM" \
  --limit 100
```

### Lambda Metrics

```bash
# Get invocation count (last hour)
aws cloudwatch get-metric-statistics \
  --namespace AWS/Lambda \
  --metric-name Invocations \
  --dimensions Name=FunctionName,Value=dr-daily-report-telegram-api-dev \
  --statistics Sum \
  --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
  --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
  --period 3600

# Get error count
aws cloudwatch get-metric-statistics \
  --namespace AWS/Lambda \
  --metric-name Errors \
  --dimensions Name=FunctionName,Value=dr-daily-report-telegram-api-dev \
  --statistics Sum \
  --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
  --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
  --period 3600
```

---

## DynamoDB Monitoring

### Table Scan for Job Status

```bash
# Count completed jobs
aws dynamodb scan \
  --table-name dr-daily-report-telegram-jobs-dev \
  --filter-expression "#s = :completed" \
  --expression-attribute-names '{"#s":"status"}' \
  --expression-attribute-values '{":completed":{"S":"completed"}}' \
  --select COUNT

# Count failed jobs
aws dynamodb scan \
  --table-name dr-daily-report-telegram-jobs-dev \
  --filter-expression "#s = :failed" \
  --expression-attribute-names '{"#s":"status"}' \
  --expression-attribute-values '{":failed":{"S":"failed"}}' \
  --select COUNT
```

### Monitoring Parallel Job Execution

```bash
#!/bin/bash
# Monitor parallel report generation

BASELINE_COMPLETED=$(aws dynamodb scan \
  --table-name dr-daily-report-telegram-jobs-dev \
  --filter-expression "#s = :completed" \
  --expression-attribute-names '{"#s":"status"}' \
  --expression-attribute-values '{":completed":{"S":"completed"}}' \
  --select COUNT \
  --output json | jq -r '.Count')

echo "Baseline: $BASELINE_COMPLETED completed jobs"

for i in {1..30}; do
  sleep 10

  COMPLETED=$(aws dynamodb scan \
    --table-name dr-daily-report-telegram-jobs-dev \
    --filter-expression "#s = :completed" \
    --expression-attribute-names '{"#s":"status"}' \
    --expression-attribute-values '{":completed":{"S":"completed"}}' \
    --select COUNT \
    --output json | jq -r '.Count')

  NEW_JOBS=$((COMPLETED - BASELINE_COMPLETED))
  echo "[$i] New completions: $NEW_JOBS/46"

  if [ "$NEW_JOBS" -ge 46 ]; then
    echo "‚úÖ All jobs completed!"
    break
  fi
done
```

---

## Common Monitoring Mistakes

### Mistake 1: Not Using Waiters

**Wrong:**
```bash
aws lambda update-function-code --function-name X --image-uri Y
sleep 60  # Guessing completion time
aws lambda invoke --function-name X ...
```

**Right:**
```bash
aws lambda update-function-code --function-name X --image-uri Y
aws lambda wait function-updated --function-name X  # Blocks until ready
aws lambda invoke --function-name X ...
```

### Mistake 2: Ignoring Exit Codes

**Wrong:**
```bash
# gh run watch without --exit-status always returns 0
gh run watch 12345
# Script continues even if workflow failed!
```

**Right:**
```bash
if ! gh run watch 12345 --exit-status; then
  echo "‚ùå Deployment failed!"
  exit 1
fi
```

### Mistake 3: Only Checking Status, Not Conclusion

**Wrong:**
```bash
STATUS=$(gh run view 12345 --json status --jq '.status')
if [ "$STATUS" = "completed" ]; then
  echo "‚úÖ Success!"  # WRONG - might have failed!
fi
```

**Right:**
```bash
RESULT=$(gh run view 12345 --json status,conclusion --jq '{status, conclusion}')
if echo "$RESULT" | grep -q '"conclusion":"success"'; then
  echo "‚úÖ Success!"
else
  echo "‚ùå Failed or cancelled"
fi
```

### Mistake 4: Not Tailing Logs Before Concluding "Bug"

**Wrong:**
```bash
# Deployment fails
echo "Must be a bug in the code!"  # Jump to conclusion
```

**Right:**
```bash
# Deployment fails
echo "Checking logs..."
gh run view 12345 --log-failed
# ‚Üí Reveals: "Permission denied" (not a code bug, IAM issue!)
```

---

## Monitoring Checklist

Before declaring a deployment "successful" or "failed", verify:

- [ ] Used AWS waiters (not `sleep`)
- [ ] Checked GitHub Actions `conclusion` (not just `status`)
- [ ] Tailed Lambda CloudWatch logs for errors
- [ ] Verified smoke test passes
- [ ] Checked metrics (invocation count, error rate)
- [ ] Monitored job status if parallel execution
- [ ] Used `--exit-status` with `gh run watch`

---

## See Also

- [Lambda Versioning](LAMBDA_VERSIONING.md) - Zero-downtime pattern
- [Deployment Workflow](WORKFLOW.md) - Complete deployment process
- [CI/CD Architecture](CI_CD.md) - GitHub Actions integration
